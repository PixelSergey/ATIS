/**
 * ATIS main program file.
 * Copyright (C) 2023 PixelSergey
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "config.h"
#include "helper.h"

/**
 * Plays a single MP3 audio clip from program memory.
 * Suitable data is generated by `encode.sh` and written to `audio.h`.
 * 
 * @param data A pointer to the audio data in MP3 format
 * @param length The length of the data array
 */
void playMp3(const unsigned char* data, unsigned int length){
    AudioOutputI2SNoDAC* out = new AudioOutputI2SNoDAC();
    AudioGeneratorMP3* aud = new AudioGeneratorMP3();

    AudioFileSourcePROGMEM* clip = new AudioFileSourcePROGMEM(data, length);
    aud->begin(clip, out);
    while(aud->loop());
    aud->stop();

    delete clip;
    delete aud;
    delete out;
}

/**
 * Plays the sound file of an individual token of speech.
 * Token names are the same as the MP3 filenames, and are also listed in the `tokenToAudio` map in `helper.h`.
 * 
 * @param token The name of the token to play
 */
void playToken(std::string token){
    auto it = tokenToAudio.find(token);
    if(it == tokenToAudio.end()){
        return;
    }

    const unsigned char* data = it->second.first;
    unsigned int length = it->second.second;
    playMp3(data, length);
}

/**
 * Download the METAR information from ilmailusaa.fi.
 * The precise URL is defined in `config.h`.
 * 
 * @return The raw JSON-formatted HTTP reponse body returned by ilmailusaa.fi 
 */
std::string getMetar(){
    BearSSL::WiFiClientSecure* client = new BearSSL::WiFiClientSecure();
    client->setInsecure();
    HTTPClient https;

    https.begin(*client, URL);
    int responseCode = https.GET();

    if(responseCode <= 0){
        D_println("Error in HTTPS request");
        return "ERROR";
    }

    std::string response = std::string(https.getString().c_str());
    https.end();
    delete client;

    D_println("Response:");
    D_println(response.c_str());

    return response;
}

/**
 * Decode the raw METAR information obtained from `getMetar()`.
 * 
 * @param metar A string containing a JSON-formatted response from ilmailusaa.fi
 * @return A string containing the current METAR information
 */
std::string decodeMetar(std::string metar){
    return "ILZD 232320Z AUTO 32020G31KT 280V340 3900=";
    StaticJsonDocument<384> jsonDocument;
    DeserializationError error = deserializeJson(jsonDocument, metar);
    if(error){
        D_print("Error deserialising JSON: ");
        D_println(error.f_str());
        return "ERROR";
    }

    std::string decoded = jsonDocument.as<JsonObject>().begin()->value()["p1"].as<std::string>();
    D_println("Decoded:");
    D_println(decoded.c_str());

    return decoded;
}

/**
 * Splits the METAR information obtained from `decodeMetar()` into individual chunks containing one piece of information each.
 * 
 * @param metar A METAR string in standard format
 * @return A vector containing the METAR information split on spaces
 */
std::vector<std::string> parseMetar(std::string metar){
    std::vector<std::string> parsed;

    // Remove terminating equals sign
    metar.pop_back();
    
    // Split string on spaces
    size_t i = 0;
    while(i != std::string::npos){
        i = metar.find(" ");
        std::string token = metar.substr(0, i);
        parsed.push_back(token);
        metar.erase(0, i+1);
    }

    D_println("Parsed:");
    for(std::string x : parsed) D_println(x.c_str());

    return parsed;
}

/**
 * Transforms the split METAR information output by `parseMetar()` into a list of tokens to be played on the speaker based on the METAR standard.
 * The official METAR standard can be found at <https://ilmailusaa.fi/pdf/Saahaitari_01-2021.pdf>.
 * @todo Implement conversion logic. Currently, a dummy value is returned.
 * 
 * @param metar A vector of METAR information
 * @return A vector containing individual speech tokens
 */
std::vector<std::string> generatePhrase(std::vector<std::string> metar){
    std::vector<std::string> phrase;

    for(std::string token : metar){
        // Simple tokens first
        if(token == "NIL"){  // No weather information
            phrase.push_back("NO_WEATHER_INFORMATION");
        }
        else if(token == "AUTO"){  // Automatic weather report
            phrase.push_back("AUTOMATIC_WEATHER_REPORT");
        }
        else if(token == "WS"){  // Windshear
            phrase.push_back("WINDSHEAR");
        }
        else if(token == "ALL"){  // Windshear on all runways
            phrase.push_back("ALL");
        }
        else if(token == "RWY"){  // Windshear on all runways
            phrase.push_back("RUNWAY");
        }
        else if(token == "NSC"){  // No significant cloud
            phrase.push_back("NO_SIGNIFICANT_CLOUD");
        }
        else if(token == "NCD"){  // No cloud detected (automatic weather stations only)
            phrase.push_back("NO_CLOUD_DETECTED");
        }

        // Slightly more complex tokens
        else if(token.length() == 3 && token.front()=='R'){  // Windshear on specific runway
            phrase.push_back("RUNWAY");
            for(char number : token.substr(1,2)) phrase.push_back(std::string(1, number));
        }
        else if(token.length() == 5 && token.front()=='Q'){  // QNH value
            phrase.push_back("QNH");
            if(token == "Q////"){
                phrase.push_back("UNKNOWN");
                continue;
            }
            for(char number : token.substr(1,4)) phrase.push_back(std::string(1, number));
        }
        else if(token.substr(0,2) == "IL" || token.substr(0,2) == "EF"){  // Station code
            phrase.push_back("THIS_IS");
            if(token == "ILZD"){
                phrase.push_back("KUMPULA");
            }
            phrase.push_back("INFORMATION");
            phrase.push_back(std::vector({"A","B","C"})[rand()%3]);
        }
        else if(token.length()==7 && token.back()=='Z' && token.substr(0,6).find_first_not_of("0123456789")==std::string::npos){ // Time
            phrase.push_back("AT");
            phrase.push_back("TIME");
            for(char number : token.substr(2,4)) phrase.push_back(std::string(1, number));
        }
        else if(token.find("KT") != std::string::npos){  // Wind
            phrase.push_back("WIND");

            // Unknown winds
            if(token == "/////KT"){
                phrase.push_back("UNKNOWN");
                continue;
            }

            // Wind direction
            if(token.substr(0,3) == "VRB"){
                phrase.push_back("VARIABLE");
            }else{
                for(char number : token.substr(0,3)) phrase.push_back(std::string(1, number));
                phrase.push_back("DEGREES");
            }

            // Wind speed and gusts
            for(char number : token.substr(3,2)) phrase.push_back(std::string(1, number));
            phrase.push_back("KNOTS");
            if(token.find("G") != std::string::npos){
                phrase.push_back("GUSTING");
                for(char number : token.substr(6,2)) phrase.push_back(std::string(1, number));
                phrase.push_back("KNOTS");
            }
        }
        else if(token.length()==7 && token[3]=='V' && token.substr(0,3).find_first_not_of("0123456789")==std::string::npos && token.substr(4,3).find_first_not_of("0123456789")==std::string::npos){  // Variable wind
            phrase.push_back("VARIABLE");
            phrase.push_back("BETWEEN");
            for(char number : token.substr(0,3)) phrase.push_back(std::string(1, number));
            phrase.push_back("AND");
            for(char number : token.substr(4,3)) phrase.push_back(std::string(1, number));
            phrase.push_back("DEGREES");
        }
        else if(token.length()==4 && (token=="////" || token.find_first_not_of("0123456789")==std::string::npos)){  // Visibility
            phrase.push_back("VISIBILITY");
            if(token == "////"){
                phrase.push_back("UNKNOWN");
                continue;
            }
            if(token == "9999"){
                phrase.push_back("1");
                phrase.push_back("0");
                phrase.push_back("KILOMETERS");
                continue;
            }
            if(token.substr(1,3) == "000"){
                phrase.push_back(std::string(1, token[0]));
                phrase.push_back("KILOMETERS");
                continue;
            }
            if(token.substr(2,2) == "00"){
                if(token[0] != '0'){
                    phrase.push_back(std::string(1, token[0]));
                    phrase.push_back("THOUSAND");
                }
                phrase.push_back(std::string(1, token[1]));
                phrase.push_back("HUNDRED");
                phrase.push_back("METERS");
                continue;
            }
            
            for(char number : token) phrase.push_back(std::string(1, number));
            phrase.push_back("METERS");
        }
        else if(token.length()>=8 && token[0]=='R' && token[3]=='/'){  // Runway visible range
            phrase.push_back("RUNWAY");
            for(char number : token.substr(1,2)) phrase.push_back(std::string(1, number));
            phrase.push_back("VISIBLE");
            phrase.push_back("RANGE");
            int offset = 0;
            if(token[5]=='M'){
                phrase.push_back("LESS");
                phrase.push_back("THAN");
                offset = 1;
            }
            if(token[5]=='P'){
                phrase.push_back("MORE");
                phrase.push_back("THAN");
                offset = 1;
            }
            for(char number : token.substr(4+offset,4)) phrase.push_back(std::string(1, number));
            phrase.push_back("METERS");
            if(token.back()=='U'){
                phrase.push_back("AND");
                phrase.push_back("INCREASING");
            }
            else if(token.back()=='D'){
                phrase.push_back("AND");
                phrase.push_back("DECREASING");
            }
            else if(token.back()=='N'){
                phrase.push_back("AND");
                phrase.push_back("REMAINING_CONSTANT");
            }
        }

        else if(token.substr(0,3) == "FEW"){
            phrase.push_back("FEW");
            if(token.substr(3,3) == "000"){
                phrase.push_back("0");
                phrase.push_back("FEET");
                continue;
            }

            if(token[3] != '0'){
                phrase.push_back(std::string(1, token[3]));
                phrase.push_back(std::string(1, token[4]));
                phrase.push_back("THOUSAND");
            }else if(token[4] != '0'){
                phrase.push_back(std::string(1, token[4]));
                phrase.push_back("THOUSAND");
            }

            if(token[5] != '0'){
                phrase.push_back(std::string(1, token[5]));
                phrase.push_back("HUNDRED");
            }

            phrase.push_back("FEET");

            if(token.substr(token.length()-3, 3)=="TCU"){
                phrase.push_back("TOWERING_CUMULUS");
            }
            if(token.substr(token.length()-2, 2)=="CB"){
                phrase.push_back("CUMULONIMBUS");
            }
        }
        else if(token.substr(0,3) == "SCT"){
            phrase.push_back("SCATTERED");
            if(token.substr(3,3) == "000"){
                phrase.push_back("0");
                phrase.push_back("FEET");
                continue;
            }

            if(token[3] != '0'){
                phrase.push_back(std::string(1, token[3]));
                phrase.push_back(std::string(1, token[4]));
                phrase.push_back("THOUSAND");
            }else if(token[4] != '0'){
                phrase.push_back(std::string(1, token[4]));
                phrase.push_back("THOUSAND");
            }

            if(token[5] != '0'){
                phrase.push_back(std::string(1, token[5]));
                phrase.push_back("HUNDRED");
            }

            phrase.push_back("FEET");

            if(token.substr(token.length()-3, 3)=="TCU"){
                phrase.push_back("TOWERING_CUMULUS");
            }
            if(token.substr(token.length()-2, 2)=="CB"){
                phrase.push_back("CUMULONIMBUS");
            }
        }
        else if(token.substr(0,3) == "BKN"){
            phrase.push_back("BROKEN");
            if(token.substr(3,3) == "000"){
                phrase.push_back("0");
                phrase.push_back("FEET");
                continue;
            }

            if(token[3] != '0'){
                phrase.push_back(std::string(1, token[3]));
                phrase.push_back(std::string(1, token[4]));
                phrase.push_back("THOUSAND");
            }else if(token[4] != '0'){
                phrase.push_back(std::string(1, token[4]));
                phrase.push_back("THOUSAND");
            }

            if(token[5] != '0'){
                phrase.push_back(std::string(1, token[5]));
                phrase.push_back("HUNDRED");
            }

            phrase.push_back("FEET");

            if(token.substr(token.length()-3, 3)=="TCU"){
                phrase.push_back("TOWERING_CUMULUS");
            }
            if(token.substr(token.length()-2, 2)=="CB"){
                phrase.push_back("CUMULONIMBUS");
            }
        }
        else if(token.substr(0,3) == "OVC"){
            phrase.push_back("OVERCAST");
            if(token.substr(3,3) == "000"){
                phrase.push_back("0");
                phrase.push_back("FEET");
                continue;
            }

            if(token[3] != '0'){
                phrase.push_back(std::string(1, token[3]));
                phrase.push_back(std::string(1, token[4]));
                phrase.push_back("THOUSAND");
            }else if(token[4] != '0'){
                phrase.push_back(std::string(1, token[4]));
                phrase.push_back("THOUSAND");
            }

            if(token[5] != '0'){
                phrase.push_back(std::string(1, token[5]));
                phrase.push_back("HUNDRED");
            }

            phrase.push_back("FEET");

            if(token.substr(token.length()-3, 3)=="TCU"){
                phrase.push_back("TOWERING_CUMULUS");
            }
            if(token.substr(token.length()-2, 2)=="CB"){
                phrase.push_back("CUMULONIMBUS");
            }
        }
        if(token.substr(0,2) == "VV"){
            phrase.push_back("VERTICAL");
            phrase.push_back("VISIBILITY");
            if(token.substr(3,3) == "000"){
                phrase.push_back("0");
                phrase.push_back("FEET");
                continue;
            }

            if(token[3] != '0'){
                phrase.push_back(std::string(1, token[3]));
                phrase.push_back(std::string(1, token[4]));
                phrase.push_back("THOUSAND");
            }else if(token[4] != '0'){
                phrase.push_back(std::string(1, token[4]));
                phrase.push_back("THOUSAND");
            }

            if(token[5] != '0'){
                phrase.push_back(std::string(1, token[5]));
                phrase.push_back("HUNDRED");
            }

            phrase.push_back("FEET");
        }
        else if(token.length()>=5 && token.find("/") != std::string::npos){  // Temperature and dewpoint
            phrase.push_back("TEMPERATURE");
            int offset = 0;
            if(token[0]=='M'){
                phrase.push_back("MINUS");
                offset += 1;
            }
            
            if(token.substr(0+offset,2)=="//"){
                phrase.push_back("UNKNOWN");
            }else{
                if(token[0+offset] == '0'){
                    phrase.push_back(std::string(1, token[0+offset+1]));
                }else{
                    for(char number : token.substr(0+offset,2)) phrase.push_back(std::string(1, number));
                }
            }

            phrase.push_back("DEWPOINT");
            if(token[3+offset]=='M'){
                phrase.push_back("MINUS");
                offset += 1;
            }
            
            if(token.substr(3+offset,2)=="//"){
                phrase.push_back("UNKNOWN");
            }else{
                if(token[3+offset] == '0'){
                    phrase.push_back(std::string(1, token[3+offset+1]));
                }else{
                    for(char number : token.substr(3+offset,2)) phrase.push_back(std::string(1, number));
                }
            }
        }
    }

    D_println("Phrase:");
    for(std::string x : phrase) D_println(x.c_str());

    return phrase;
}

/**
 * Combines the above functions to automatically download and convert current METAR information into a list of tokens.
 * 
 * @return A vector containing the speech tokens corresponding to current METAR information
 */
std::vector<std::string> getNewMetarPhrase(){
    std::string metar = getMetar();
    std::string decoded = decodeMetar(metar);
    std::vector<std::string> parsed = parseMetar(decoded);
    std::vector<std::string> phrase = generatePhrase(parsed);
    return phrase;
}

/**
 * Sets up the NodeMCU's pins and WiFi connectivity.
 */
void setup(){
    // Pin setup
    pinMode(LED, OUTPUT);
    digitalWrite(LED, HIGH);  // Turn on setup light
    D_SerialBegin(115200);

    // WiFi setup
    // The WiFiManager class is rather heavy.
    // These curly brackets create a scope for wifiManager,
    // so that the object is destroyed after a connection is established.
    {
        WiFiManager wifiManager;
        wifiManager.autoConnect("ATIS");
    }

    // Turn off setup light
    digitalWrite(LED, LOW);
}

/**
 * Main program loop
 */
void loop(){
    std::vector<std::string> phrase = getNewMetarPhrase();
    for(int i=0; i<phrase.size(); i++) playToken(phrase[i]);
    
    delay(2000);
}
