/**
 * ATIS main program file.
 * Copyright (C) 2023 PixelSergey
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "config.h"
#include "helper.h"

TokenType phrase[200];

/**
 * @brief Plays a single MP3 audio clip from program memory.
 * Suitable data is generated by `encode.sh` and written to `audio.h`.
 * 
 * @param data A pointer to the audio data in MP3 format
 * @param length The length of the data array
 */
void playMp3(const unsigned char* data, unsigned int length){
    D_print("Playing ");
    AudioOutputI2SNoDAC* out = new AudioOutputI2SNoDAC();
    AudioGeneratorMP3* aud = new AudioGeneratorMP3();
    AudioFileSourcePROGMEM* clip = new AudioFileSourcePROGMEM(data, length);

    D_print("Looping ");
    aud->begin(clip, out);
    while(aud->loop());
    aud->stop();

    D_print("Deleting ");

    delete clip;
    delete aud;
    delete out;

    D_println("Exiting");
}

/**
 * @brief Plays the sound file of an individual token of speech.
 * All available token names can be found in the TokenType enum in `helper.h`.
 * 
 * @param token The token to play
 */
void playToken(TokenType token){
    if(token >= std::size(tokenToAudio)) return;

    const unsigned char* data = tokenToAudio[token].first;
    unsigned int length = tokenToAudio[token].second;
    playMp3(data, length);
}

/**
 * @brief Downloads the METAR information from ilmailusaa.fi.
 * The precise URL is defined in the URL variable in `config.h`.
 * 
 * @param[out] response A pointer to a char array, where the raw JSON-formatted data from ilmailusaa.fi will be written
 * @param[in] size_response The maximum size of the `response` array
 */
void getMetar(char* response, int size_response){
    std::unique_ptr<BearSSL::WiFiClientSecure> client(new BearSSL::WiFiClientSecure);
    client->setInsecure();
    HTTPClient https;
    https.setReuse(false);

    https.begin(*client, URL);
    int responseCode = https.GET();

    if(responseCode <= 0){
        D_println("Error in HTTPS request");
        strncpy(response, "ERROR", size_response);
        response[size_response-1] = '\0';
        return;
    }

    strncpy(response, https.getString().c_str(), size_response);
    response[size_response-1] = '\0';
    https.end();
    client.reset();

    D_println("Response:");
    D_println(response);
}

/**
 * @brief Decodes the raw METAR information obtained from `getMetar()`.
 *
 * @param[out] metar A pointer to a char array, where the current decoded METAR information will be written
 * @param[in] size_metar The maximum size of the `metar` array
 * @param[in] raw A pointer to a char array with raw JSON-formatted data from ilmailusaa.fi
 * @param[in] size_raw The size of the `raw` array
 * @return The number of characters written to `metar`
 */
int decodeMetar(char* metar, int size_metar, char* raw, int size_raw){
    char* begin = strstr(raw, "\"p1\":\"");
    if(begin == NULL){
        strncpy(metar, "ERROR", size_metar);
        metar[size_metar-1] = '\0';
        return min(5, size_metar);
    }
    begin += 6;

    char* end = strstr(begin, "\"");
    if(end == NULL || size_metar < end-begin){
        strncpy(metar, "ERROR", size_metar);
        metar[size_metar-1] = '\0';
        return min(5, size_metar);
    }

    int copied = end-begin-1;
    strncpy(metar, begin, copied);
    metar[copied] = '\0';
    D_print("Decoded: ");
    D_println(metar);
    return copied+1;
}

/**
 * @brief Splits the METAR information obtained from `decodeMetar()` into individual chunks containing one piece of information each.
 * 
 * @param[out] parsed A pointer to an array of character pointers, where the pointers to each piece of METAR information will be written 
 * @param[in] size_parsed The maximum size of the `parsed` array
 * @param[in] metar A pointer to a char array containing the current decoded METAR information
 * @param[in] size_metar The size of the `metar` array
 * @return The number of characters written to `parsed`
 */
int parseMetar(char** parsed, int size_parsed, char* metar, int size_metar){
    // Split string on spaces
    parsed[0] = metar;
    int j = 1;
    for(int i=0; i<size_metar; i++){
        if(metar[i] == ' '){
            metar[i] = '\0';
            parsed[j] = metar + i + 1;
            j++;
        }
    }

    D_print("Parsed: ");
    for(int i=0; i<j; i++){
        D_print(parsed[i]);
        D_print("|");
    }
    D_println();
    return j;
}

/**
 * @brief Pushes a single token onto the phrase array, ensuring that it is not written outside the array's bounds.
 * 
 * @param[out] phrase A TokenType array to write to
 * @param[in] size_phrase The maximum size of `phrase`
 * @param[out] pos Current position, passed by reference. This will be updated
 * @param[in] token The token to push
 */
void pushToken(TokenType* phrase, int size_phrase, int& pos, TokenType token){
    if(pos >= size_phrase){
        pos = size_phrase;
        return;
    }

    D_print("Pushing "); D_println(token);
    phrase[pos] = token;
    pos++;
}

/**
 * @brief Pushes a string of numbers (0-9) onto the phrase array
 * 
 * @param[out] phrase A TokenType array to write to
 * @param[in] size_phrase The maximum size of `phrase`
 * @param[out] pos Current position, passed by reference. This will be updated
 * @param[in] numbers A pointer to a char array of ASCII numbers
 * @param[in] count The number of elements to push
 */
void pushNumbers(TokenType* phrase, int size_phrase, int& pos, const char* numbers, int count){
    for(int i=0; i<count; i++) pushToken(phrase, size_phrase, pos, TokenType(numbers[i]-'0'+ZERO));
}

/**
 * @brief Pushes a string of uppercase characters (A-Z) onto the phrase array
 * 
 * @param[out] phrase A TokenType array to write to
 * @param[in] size_phrase The maximum size of `phrase`
 * @param[out] pos Current position, passed by reference. This will be updated
 * @param[in] chars A pointer to a char array of uppercase ASCII characters
 * @param[in] count The number of elements to push
 */
void pushChars(TokenType* phrase, int size_phrase, int& pos, const char* chars, int count){
    for(int i=0; i<count; i++) pushToken(phrase, size_phrase, pos, TokenType(chars[i]-'A'+ALPHA));
}

/**
 * @brief Pushes a four-digit distance value in meters to the phrase array
 * 
 * @param[out] phrase A TokenType array to write to
 * @param[in] size_phrase The maximum size of `phrase`
 * @param[out] pos Current position, passed by reference. This will be updated
 * @param[in] distance A pointer to a char array representing a distance in metres. The array must consist of 4 ASCII digits (0-9) 
 */
void pushDistance(TokenType* phrase, int size_phrase, int& pos, const char* distance){
    if(strncmp(distance, "9999", 4) == 0){
        PushToken(ONE);
        PushToken(ZERO);
        PushToken(KILOMETERS);
        return;
    }
    if(strncmp(distance, "0000", 4) == 0){
        PushToken(ZERO);
        PushToken(METERS);
        return;
    }
    if(strncmp(distance+1, "000", 3) == 0){
        pushNumbers(phrase, size_phrase, pos, distance, 1);
        PushToken(KILOMETERS);
        return;
    }
    if(strncmp(distance+2, "00", 2) == 0){
        if(strncmp(distance, "0", 1) != 0){
            pushNumbers(phrase, size_phrase, pos, distance, 1);
            PushToken(THOUSAND);
        }
        pushNumbers(phrase, size_phrase, pos, distance+1, 1);
        PushToken(HUNDRED);
        PushToken(METERS);
        return;
    }

    pushNumbers(phrase, size_phrase, pos, distance, 4);
    PushToken(METERS);
}

/**
 * @brief Pushes a string of weather symbols onto the phrase array
 * 
 * @param[out] phrase A TokenType array to write to
 * @param[in] size_phrase The maximum size of `phrase`
 * @param[out] pos Current position, passed by reference. This will be updated
 * @param[in] weather A pointer to a char array containing weather symbols
 * @param[in] length The length of `weather`. Must be even
 */
void pushWeather(TokenType* phrase, int size_phrase, int& pos, const char* weather, int length){
    int len = sizeof(weatherType)/sizeof(int);
    for(int i=0; 2*i<length; i++){
        const int value = weather[2*i] | (weather[2*i+1] << 8);
        int weather_index = std::find(weatherType, weatherType+len, value) - weatherType;
        if(weather_index >= len) continue;
        PushToken(TokenType(VICINITY + weather_index))
    }
}

/**
 * @brief Pushes a three-digit height value in feet to the phrase array
 * 
 * @param[out] phrase A TokenType array to write to
 * @param[in] size_phrase The maximum size of `phrase`
 * @param[out] pos Current position, passed by reference. This will be updated
 * @param[in] height A pointer to a char array representing a height in hundreds of feet. The array must consist of 3 ASCII digits (0-9)
 */
void pushHeight(TokenType* phrase, int size_phrase, int& pos, const char* height){
    if(strncmp(height, "000", 3) == 0){
        PushToken(ZERO);
        PushToken(FEET);
        return;
    }

    if(strncmp(height, "0", 1) != 0){
        PushNumbers(height, 2);
        PushToken(THOUSAND);
    }else if(strncmp(height+1, "0", 1) != 0){
        PushNumbers(height+1, 1);
        PushToken(THOUSAND);
    }

    if(strncmp(height+2, "0", 1) != 0){
        PushNumbers(height+2, 1);
        PushToken(HUNDRED);
    }

    PushToken(FEET);
}

/**
 * @brief Pushes a set of speech tokens to the end of the `phrase` array depending on the information type and regex match
 * 
 * @param[out] phrase A TokenType array to write to
 * @param[in] size_phrase The maximum size of `phrase`
 * @param[out] pos Current position in the TokenType array
 * @param[in] match Regex match object, passed by reference
 * @param[in] type The type of METAR information to process
 * @return The number of tokens written to `phrase`
 */
int convertToken(TokenType* phrase, int size_phrase, int pos, std::cmatch& match, InformationType type){
    D_println("Converting");
    switch(type){
        case I_STATION:
            PushToken(THIS_IS);
            if(Matched(1)){
                PushToken(HYVINKAA);
            }else if(Matched(2)){
                PushToken(KUMPULA);
            }else if(Matched(3)){
                PushChars(Match(3), 4);
            }
            PushToken(INFORMATION);
            PushToken(ALPHA);
            break;

        case I_TIME:
            PushToken(AT); PushToken(TIME);
            PushNumbers(Match(1), 4);
            PushToken(ZULU);
            break;

        case I_NIL:
            PushToken(NO_WEATHER_INFORMATION);
            break;

        case I_AUTO:
            PushToken(AUTOMATIC_WEATHER_REPORT);
            break;

        case I_WIND:
            PushToken(WIND);
            if(Matched(1)){
                PushToken(UNKNOWN);
                break;
            }
            if(Matched(2)){
                PushToken(CALM);
                break;
            }
            if(Matched(3)) PushToken(VARIABLE);
            if(Matched(4)){
                PushNumbers(Match(4), 3);
                PushToken(DEGREES);
            }
            if(Matched(5)){
                PushNumbers(Match(5), 2);
                PushToken(KNOTS);
            }
            if(Matched(6)){
                PushToken(GUSTING);
                PushNumbers(Match(6), 2);
                PushToken(KNOTS);
            }
            break;

        case I_VARIABLE:
            PushToken(VARIABLE);
            PushToken(BETWEEN);
            PushNumbers(Match(1), 3);
            PushToken(AND);
            PushNumbers(Match(2), 3);
            PushToken(DEGREES);
            break;

        case I_CAVOK:
            PushToken(CAVOK);
            break;

        case I_VISIBILITY:
            PushToken(VISIBILITY);
            if(Matched(1)){
                PushToken(UNKNOWN);
                break;
            }
            if(Matched(2)){
                PushDistance(Match(2));
            }
            break;

        case I_RVR:
            PushToken(RUNWAY);
            PushNumbers(Match(1), 2);
            PushToken(VISIBLE_RANGE);
            if(Matched(2)){
                PushToken(LESS_THAN);
            }else if(Matched(3)){
                PushToken(MORE_THAN);
            }
            PushDistance(Match(4));
            if(Matched(5)){
                PushToken(AND);
                PushToken(INCREASING);
            }else if(Matched(6)){
                PushToken(AND);
                PushToken(DECREASING);
            }else if(Matched(7)){
                PushToken(AND);
                PushToken(REMAINING);
            }
            break;

        case I_WEATHER:
            if(Matched(1)){
                PushToken(WEATHER);
                PushToken(UNKNOWN);
                break;
            }
            if(Matched(2)) PushToken(HEAVY);
            if(Matched(3)) PushToken(LIGHT);
            if(Matched(4)) PushWeather(Match(4), Matched(4));
            break;

        case I_CLOUD:
            if(Matched(1)){
                if(!Matched(7) && !Matched(8)){
                    PushToken(CLOUDS);
                    PushToken(UNKNOWN);
                    break;
                }
                if(Matched(7)) PushToken(CUMULONIMBUS);
                if(Matched(8)) PushToken(TOWERING_CUMULUS);
                PushToken(CLOUDS);
                break;
            }
            if(Matched(2)) PushToken(FEW);
            if(Matched(3)) PushToken(SCATTERED);
            if(Matched(4)) PushToken(BROKEN);
            if(Matched(5)) PushToken(OVERCAST);
            if(Matched(6)) PushHeight(Match(6));
            if(Matched(7)) PushToken(CUMULONIMBUS);
            if(Matched(8)) PushToken(TOWERING_CUMULUS);
            break;

        case I_NSC:
            PushToken(NO_SIGNIFICANT_CLOUD);
            break;

        case I_NCD:
            PushToken(NO_CLOUD_DETECTED);
            break;

        case I_VERTICAL:
            PushToken(VERTICAL);
            PushToken(VISIBILITY);
            PushHeight(Match(1));
            break;

        case I_TEMPERATURE:
            PushToken(TEMPERATURE);
            if(Matched(1)) PushToken(MINUS);
            if(Matched(2)) PushNumbers(Match(2), 2);
            if(Matched(3)) PushToken(UNKNOWN);
            PushToken(DEWPOINT);
            if(Matched(4)) PushToken(MINUS);
            if(Matched(5)) PushNumbers(Match(5), 2);
            if(Matched(6)) PushToken(UNKNOWN);
            break;

        case I_QNH:
            PushToken(QNH);
            if(Matched(1)) PushNumbers(Match(1), 4);
            if(Matched(2)) PushToken(UNKNOWN);
            break;

        case I_WINDSHEAR:
            PushToken(WINDSHEAR);
            break;

        case I_ALL:
            PushToken(ALL);
            break;

        case I_RWY:
            PushToken(RUNWAY);
            break;

        case I_RUNWAY_NUMBER:
            PushToken(RUNWAY);
            PushNumbers(Match(1), 2);
            break;

        default:
        case I_ERROR:
            PushToken(ERROR);
            break;
    }
    return pos;
}

/**
 * @brief Transforms the split METAR information output by `parseMetar()` into a list of tokens to be played on the speaker based on the METAR standard.
 * The official METAR standard can be found at https://ilmailusaa.fi/pdf/Saahaitari_01-2021.pdf.
 * 
 * @param[out] phrase A TokenType array to write to
 * @param[in] size_phrase The maximum size of `phrase`
 * @param[in] metar A pointer to an array of character pointers, containing the pointers to each piece of METAR information
 * @param[in] size_metar The size of the `metar` array
 * @return The number of tokens written to `phrase`
 */
int generatePhrase(TokenType* phrase, int size_phrase, char** metar, int size_metar){
    int pos = 0;
    for(int i=0; i<size_metar; i++){
        InformationType type = I_ERROR;
        std::cmatch match;
        D_print("Searching match for "); D_println(metar[i]);
        for(std::pair<const char*, InformationType> it : regexToToken){
            bool found = std::regex_match(metar[i], match, std::regex(it.first));
            if(!found) continue;

            D_print("Found match for "); D_print(metar[i]); D_print(" with type "); D_println(it.second);
            type = it.second;
            break;
        }

        pos = convertToken(phrase, size_phrase, pos, match, type);
    }

    D_print("Phrase: ");
    for(int i=0; i<pos; i++){
        D_print(phrase[i]);
        D_print(" ");
    }
    D_println();
    return pos;
}

/**
 * Downloads the current METAR information, processed it, and converts it into an array of tokens.
 * 
 * @param[out] phrase A TokenType array, where the speech tokens corresponding to current METAR information will be written
 * @param[in] size_phrase The maximum size of `phrase`
 * @return The number of tokens written
 */
int getNewMetarPhrase(TokenType* phrase, int size_phrase){
    char response[350];
    char metar[150];
    char* parsed[25];
    getMetar(response, 350);
    int size_metar = decodeMetar(metar, 150, response, 350);
    int size_parsed = parseMetar(parsed, 25, metar, size_metar);
    int size_generated = generatePhrase(phrase, size_phrase, parsed, size_parsed);
    return size_generated;
}

/**
 * Sets up the NodeMCU's pins and WiFi connectivity.
 */
void setup(){
    // Pin setup
    pinMode(LED, OUTPUT);
    digitalWrite(LED, HIGH);  // Turn on setup light
    D_SerialBegin(115200);

    WiFi.mode(WIFI_STA);
    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);

    while(WiFi.status() != WL_CONNECTED) delay(100);
    D_println("WiFi connected");

    // Turn off setup light
    digitalWrite(LED, LOW);
}

/**
 * Main program loop
 */
void loop(){
    int size_generated = getNewMetarPhrase(phrase, 200);
    D_println("Generation complete!");
    for(int i=0; i<size_generated; i++) playToken(phrase[i]);
    D_println("End of loop\n-----------------------\n");
    delay(2000);
}
