/**
 * ATIS main program file.
 * Copyright (C) 2023 PixelSergey
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "config.h"
#include "helper.h"

/**
 * Plays a single MP3 audio clip from program memory.
 * Suitable data is generated by `encode.sh` and written to `audio.h`.
 * 
 * @param data A pointer to the audio data in MP3 format
 * @param length The length of the data array
 */
void playMp3(const unsigned char* data, unsigned int length){
    AudioOutputI2SNoDAC* out = new AudioOutputI2SNoDAC();
    AudioGeneratorMP3* aud = new AudioGeneratorMP3();

    AudioFileSourcePROGMEM* clip = new AudioFileSourcePROGMEM(data, length);
    aud->begin(clip, out);
    while(aud->loop());
    aud->stop();

    delete clip;
    delete aud;
    delete out;
}

/**
 * Plays the sound file of an individual token of speech.
 * Token names are the same as the MP3 filenames, and are also listed in the `tokenToAudio` map in `helper.h`.
 * 
 * @param token The name of the token to play
 */
void playToken(std::string token){
    auto it = tokenToAudio.find(token);
    if(it == tokenToAudio.end()){
        return;
    }

    const unsigned char* data = it->second.first;
    unsigned int length = it->second.second;
    playMp3(data, length);
}

/**
 * Download the METAR information from ilmailusaa.fi.
 * The precise URL is defined in `config.h`.
 * 
 * @return The raw JSON-formatted HTTP reponse body returned by ilmailusaa.fi 
 */
std::string getMetar(){
    BearSSL::WiFiClientSecure* client = new BearSSL::WiFiClientSecure();
    client->setInsecure();
    HTTPClient https;

    https.begin(*client, URL);
    int responseCode = https.GET();

    if(responseCode <= 0){
        D_println("Error in HTTPS request");
        return "ERROR";
    }

    std::string response = std::string(https.getString().c_str());
    https.end();
    delete client;

    D_println("Response:");
    D_println(response.c_str());

    return response;
}

/**
 * Decode the raw METAR information obtained from `getMetar()`.
 * 
 * @param metar A string containing a JSON-formatted response from ilmailusaa.fi
 * @return A string containing the current METAR information
 */
std::string decodeMetar(std::string metar){
    StaticJsonDocument<384> jsonDocument;
    DeserializationError error = deserializeJson(jsonDocument, metar);
    if(error){
        D_print("Error deserialising JSON: ");
        D_println(error.f_str());
        return "ERROR";
    }

    std::string decoded = jsonDocument.as<JsonObject>().begin()->value()["p1"].as<std::string>();
    D_println("Decoded:");
    D_println(decoded.c_str());

    return decoded;
}

/**
 * Splits the METAR information obtained from `decodeMetar()` into individual chunks containing one piece of information each.
 * 
 * @param metar A METAR string in standard format
 * @return A vector containing the METAR information split on spaces
 */
std::vector<std::string> parseMetar(std::string metar){
    std::vector<std::string> parsed;

    // Remove terminating equals sign
    metar.pop_back();
    
    // Split string on spaces
    size_t i = 0;
    while(i != std::string::npos){
        i = metar.find(" ");
        std::string token = metar.substr(0, i);
        parsed.push_back(token);
        metar.erase(0, i+1);
    }

    D_println("Parsed:");
    for(std::string x : parsed) D_println(x.c_str());

    return parsed;
}

/**
 * Transforms the split METAR information output by `parseMetar()` into a list of tokens to be played on the speaker based on the METAR standard.
 * The official METAR standard can be found at <https://ilmailusaa.fi/pdf/Saahaitari_01-2021.pdf>.
 * @todo Implement conversion logic. Currently, a dummy value is returned.
 * 
 * @param metar A vector of METAR information
 * @return A vector containing individual speech tokens
 */
std::vector<std::string> generatePhrase(std::vector<std::string> metar){
    std::vector<std::string> phrase;

    phrase.push_back("THIS_IS");
    phrase.push_back("KUMPULA");
    phrase.push_back("INFORMATION");

    int time = millis();
    phrase.push_back(time % 3 == 0 ? "A" : (time % 3 == 1 ? "B" : "C"));

    D_println("Phrase:");
    for(std::string x : phrase) D_println(x.c_str());

    return phrase;
}

/**
 * Combines the above functions to automatically download and convert current METAR information into a list of tokens.
 * 
 * @return A vector containing the speech tokens corresponding to current METAR information
 */
std::vector<std::string> getNewMetarPhrase(){
    std::string metar = getMetar();
    std::string decoded = decodeMetar(metar);
    std::vector<std::string> parsed = parseMetar(decoded);
    std::vector<std::string> phrase = generatePhrase(parsed);
    return phrase;
}

/**
 * Sets up the NodeMCU's pins and WiFi connectivity.
 */
void setup(){
    // Pin setup
    pinMode(LED, OUTPUT);
    digitalWrite(LED, HIGH);  // Turn on setup light
    D_SerialBegin(115200);

    // WiFi setup
    // The WiFiManager class is rather heavy.
    // These curly brackets create a scope for wifiManager,
    // so that the object is destroyed after a connection is established.
    {
        WiFiManager wifiManager;
        wifiManager.autoConnect("ATIS");
    }

    // Turn off setup light
    digitalWrite(LED, LOW);
}

/**
 * Main program loop
 */
void loop(){
    std::vector<std::string> phrase = getNewMetarPhrase();
    for(int i=0; i<phrase.size(); i++) playToken(phrase[i]);
    
    delay(2000);
}
